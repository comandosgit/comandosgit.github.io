<article class="row" id="basico">
    <h2 class="col-xs-12">Básico</h2>

    <div class="col-xs-12">
        <h4 id="gitadd">git add</h4>
        <!-- Nav tabs -->
        <ul class="nav nav-tabs" role="tablist">
            <li class="active"><a href="#gitadd1" role="tab" data-toggle="tab"><h3>Gravando Alterações</h3></a>
            </li>
        </ul>
        <!-- Tab panes -->
        <div class="tab-content">
            <div class="tab-pane fade in active" id="gitadd1">
                <br/>

                <p>Quando um repositório é inicialmente clonado, todos os seus arquivos estarão monitorados e inalterados porque você simplesmente os obteve e ainda não os editou. Conforme você edita esses arquivos, o Git passa a vê-los como modificados, porque você os alterou desde seu último commit. Você seleciona esses arquivos modificados e então faz o commit de todas as alterações selecionadas e o ciclo se repete.</p>
                <h5>Monitorando Novos Arquivos</h5>

                <p>Para passar a monitorar um novo arquivo, use o comando <b>git add</b>. Para monitorar o arquivo
                    <b>README</b>, você pode rodar isso:</p>

                <div class="well well-sm">git add README</div>
                <p>Se você rodar o comando <b>git status</b>, você pode ver que o seu arquivo <b>README</b> agora está sendo monitorado. Os arquivos monitorados serão os que faram parte do commit.</p>
            </div>
        </div>
    </div>
    <div class="col-xs-12">
        <h4 id="gitstatus">git status</h4>
        <!-- Nav tabs -->
        <ul class="nav nav-tabs" role="tablist">
            <li class="active"><a href="#gitstatus1" role="tab" data-toggle="tab"><h3>Verificando o Status</h3></a>
            </li>
        </ul>
        <!-- Tab panes -->
        <div class="tab-content">
            <div class="tab-pane fade in active" id="gitstatus1">
                <br/>

                <p>A principal ferramenta utilizada para determinar quais arquivos estão em quais estados é o comando:
                </p>

                <div class="well well-sm">git status</div>
                <p>O comando lhe mostra em qual branch você se encontra. Vamos dizer que você adicione um novo arquivo em seu projeto, um simples arquivo <b>README</b>. Caso o arquivo não exista e você execute <b>git status</b>, você verá o arquivo não monitorado dessa forma:</p>

                <div class="well well-sm"># On branch master
                    <br/># Untracked files:
                    <br/># (use "git add {file}..." to include in what will be committed)
                    <br/>#
                    <br/># README
                    <br/>nothing added to commit but untracked files present (use "git add" to track)
                </div>
                <p>Você pode ver que o seu novo arquivo <b>README</b> não está sendo monitorado, pois está listado sob o cabeçalho <b>"Untracked files"</b> na saída do comando status. Não monitorado significa basicamente que o Git está vendo um arquivo que não existia na última captura (commit); o Git não vai incluí-lo nas suas capturas de commit até que você o diga explicitamente que assim o faça. Ele faz isso para que você não inclua acidentalmente arquivos binários gerados, ou outros arquivos que você não têm a intenção de incluir. Digamos, que você queira incluir o arquivo <b>README</b>, portanto vamos começar a monitorar este arquivo.</p>
            </div>
        </div>
    </div>

    <div class="col-xs-12">
        <h4 id="gitdiff">git diff</h4>
        <!-- Nav tabs -->
        <ul class="nav nav-tabs" role="tablist">
            <li class="active"><a href="#gitdiff1" role="tab" data-toggle="tab"><h3>Verificando Mudanças</h3></a>
            </li>
        </ul>
        <!-- Tab panes -->
        <div class="tab-content">
            <div class="tab-pane fade in active" id="gitdiff1">
                <br/>

                <p>Se o comando <b>git status</b> for muito vago — você quer saber exatamente o que você alterou, não apenas quais arquivos foram alterados — você pode utilizar o comando.</p>

                <div class="well well-sm">git diff</div>
                <p>Apesar do comando <b>git status</b> responder essas duas perguntas de maneira geral, o <b>git
    diff</b> mostra as linhas exatas que foram adicionadas e removidas — o patch, por assim dizer.
                    <br/>Se você quer ver o que selecionou que irá no seu próximo commit, pode utilizar:</p>

                <div class="well well-sm">git diff --cached</div>

            </div>
        </div>
    </div>
    <div class="col-xs-12">
        <h4 id="gitcommit">git commit</h4>
        <!-- Nav tabs -->
        <ul class="nav nav-tabs" role="tablist">
            <li class="active"><a href="#gitcommit1" role="tab" data-toggle="tab"><h3>Commits</h3></a>
            </li>
        </ul>
        <!-- Tab panes -->
        <div class="tab-content">
            <div class="tab-pane fade in active" id="gitcommit1">
                <br/>

                <p>Armazena o conteúdo atual do índice em um novo commit, juntamente com uma mensagem de registro do usuário que descreve as mudanças.
                    <br/>Se usa o commit depois de já ter feito o <b>git add</b>, para fazer o commit:</p>

                <div class="well well-sm">git commit -m "Mensagem"</div>
                <p>Para commitar também os arquivos versionados mesmo não estando no Stage basta adicionar o parâmetro -a</p>

                <div class="well well-sm">git commit <b>-a</b> -m "Mensagem"</div>
                <p>Refazendo commit quando esquecer de adicionar um arquivo no Stage:</p>

                <div class="well well-sm">git commit -m "Mensagem" <b>--amend</b>
                </div>
                <p>O amend é destrutivo e só deve ser utilizado antes do commit ter sido enviado ao servidor remoto.
                </p>
            </div>
        </div>
    </div>
    <div class="col-xs-12">
        <h4 id="gitreset">git reset</h4>
        <!-- Nav tabs -->
        <ul class="nav nav-tabs" role="tablist">
            <li class="active"><a href="#gitreset1" role="tab" data-toggle="tab"><h3>Desfazendo Coisas</h3></a>
            </li>
        </ul>
        <!-- Tab panes -->
        <div class="tab-content">
            <div class="tab-pane fade in active" id="gitreset1">
                <br/>

                <p>Em qualquer fase, você pode querer desfazer alguma coisa. Aqui, veremos algumas ferramentas básicas para desfazer modificações que você fez. Cuidado, porque você não pode desfazer algumas dessas mudanças. Essa é uma das poucas áreas no Git onde você pode perder algum trabalho se fizer errado.
                    <br/>Para voltar ao último commit:</p>

                <div class="well well-sm">git reset --hard HEAD~1</div>
                <p>Para voltar ao último commit e mantém os últimos arquivos no Stage:</p>

                <div class="well well-sm">git reset --soft HEAD~1</div>
                <p>Volta para o commit com a hash XXXXXXXXXXX:</p>

                <div class="well well-sm">git reset --hard XXXXXXXXXXX</div>
                <h5>Recuperando commit apagado pelo git reset</h5>

                <p>Para visualizar os hashs</p>

                <div class="well well-sm">git reflog</div>
                <p>E para aplicar:</p>

                <div class="well well-sm">git merge {hash}</div>
            </div>
        </div>
    </div>
    <div class="col-xs-12">
        <h4 id="gitrm">git rm</h4>
        <!-- Nav tabs -->
        <ul class="nav nav-tabs" role="tablist">
            <li class="active"><a href="#gitrm1" role="tab" data-toggle="tab"><h3>Removendo Arquivos</h3></a>
            </li>
        </ul>
        <!-- Tab panes -->
        <div class="tab-content">
            <div class="tab-pane fade in active" id="gitrm1">
                <br/>

                <p>Para remover um arquivo do Git, você tem que removê-lo dos arquivos que estão sendo monitorados (mais precisamente, removê-lo da sua área de seleção) e então fazer o commit. O comando <b>git
    rm</b> faz isso e também remove o arquivo do seu diretório para você não ver ele como arquivo não monitorado (untracked file) na próxima vez.
                </p>

                <div class="well well-sm">git rm -f {arquivo}</div>
                <p>Se você modificou o arquivo e já o adicionou na área de seleção, você deve forçar a remoção com a opção <b>-f</b>. Essa é uma funcionalidade de segurança para prevenir remoções acidentais de dados que ainda não foram gravados em um snapshot e não podem ser recuperados do Git.</p>

            </div>
        </div>
    </div>
    <div class="col-xs-12">
        <h4 id="gitmv">git mv</h4>
        <!-- Nav tabs -->
        <ul class="nav nav-tabs" role="tablist">
            <li class="active"><a href="#gitmv1" role="tab" data-toggle="tab"><h3>Movendo Arquivos</h3></a>
            </li>
        </ul>
        <!-- Tab panes -->
        <div class="tab-content">
            <div class="tab-pane fade in active" id="gitmv1">
                <br/>

                <p>Diferente de muitos sistemas VCS, o Git não monitora explicitamente arquivos movidos.
                    <br/>É um pouco confuso que o Git tenha um comando <b>mv</b>. Se você quiser renomear um arquivo no Git, você pode fazer isso com</p>

                <div class="well well-sm">git mv arquivo_origem arquivo_destino</div>
                <p>e funciona. De fato, se você fizer algo desse tipo e consultar o status, você verá que o Git considera que o arquivo foi renomeado.</p>

                <p>No entanto, isso é equivalente a rodar algo como:</p>

                <div class="well well-sm">mv README.txt README
                    <br/>git rm README.txt
                    <br/>git add README</div>
                <p>O Git descobre que o arquivo foi renomeado implicitamente, então ele não se importa se você renomeou por este caminho ou com o comando <b>mv</b>. A única diferença real é que o comando
                    <b>mv</b>
                    é mais conveniente, executa três passos de uma vez. O mais importante, você pode usar qualquer ferramenta para renomear um arquivo, e usar add/rm depois, antes de consolidar com o commit.</p>
            </div>
        </div>
    </div>
</article>
